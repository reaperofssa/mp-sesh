<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Live Stream Player</title>
<style>
  body {
    font-family: 'Segoe UI', sans-serif;
    background: #121212;
    color: #fff;
    margin: 0;
    padding: 20px;
    min-height: 100vh;
  }
  .container {
    max-width: 800px;
    margin: 0 auto;
    display: grid;
    grid-template-columns: 1fr 300px;
    gap: 20px;
  }
  .player {
    background: #1e1e1e;
    padding: 25px 30px;
    border-radius: 12px;
    text-align: center;
    box-shadow: 0 8px 20px rgba(0,0,0,0.5);
    height: fit-content;
  }
  .sidebar {
    background: #1e1e1e;
    padding: 20px;
    border-radius: 12px;
    box-shadow: 0 8px 20px rgba(0,0,0,0.5);
    height: fit-content;
  }
  .cover {
    width: 100%; height: 200px; margin-bottom: 15px;
    border-radius: 10px; object-fit: cover; background: #333;
  }
  .song-title {
    font-size: 18px; font-weight: bold; margin-bottom: 5px;
    overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
  }
  .song-meta { font-size: 14px; color: #aaa; margin-bottom: 15px; }
  .progress-container {
    background: #333; height: 8px; border-radius: 8px;
    width: 100%; margin-bottom: 20px; overflow: hidden;
  }
  .progress {
    background: #1db954; width: 0%; height: 100%;
    transition: width 0.15s linear;
  }
  #startBtn {
    background: #1db954; border: none; color: #fff;
    padding: 12px 25px; border-radius: 25px; cursor: pointer; font-size: 16px;
  }
  #startBtn:hover { background: #1ed760; }
  
  /* Sidebar Styles */
  .section {
    margin-bottom: 30px;
  }
  .section h3 {
    font-size: 16px;
    margin-bottom: 15px;
    color: #fff;
    border-bottom: 2px solid #1db954;
    padding-bottom: 5px;
  }
  .users-list {
    max-height: 200px;
    overflow-y: auto;
  }
  .user-item {
    display: flex;
    align-items: center;
    padding: 8px 0;
    border-bottom: 1px solid #333;
  }
  .user-item:last-child {
    border-bottom: none;
  }
  .user-avatar {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background: #1db954;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 10px;
    font-weight: bold;
    font-size: 14px;
  }
  .user-name {
    font-size: 14px;
    color: #fff;
  }
  .queue-list {
    max-height: 300px;
    overflow-y: auto;
  }
  .queue-item {
    display: flex;
    padding: 10px 0;
    border-bottom: 1px solid #333;
  }
  .queue-item:last-child {
    border-bottom: none;
  }
  .queue-item.current {
    background: rgba(29, 185, 84, 0.1);
    border-radius: 8px;
    padding: 10px;
    margin: 5px 0;
  }
  .queue-thumbnail {
    width: 40px;
    height: 40px;
    border-radius: 6px;
    object-fit: cover;
    margin-right: 10px;
    background: #333;
  }
  .queue-info {
    flex: 1;
  }
  .queue-title {
    font-size: 13px;
    font-weight: 500;
    color: #fff;
    margin-bottom: 3px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .queue-duration {
    font-size: 12px;
    color: #aaa;
  }
  .queue-index {
    font-size: 12px;
    color: #1db954;
    margin-right: 10px;
    font-weight: bold;
    min-width: 20px;
  }
  .current-indicator {
    color: #1db954;
    font-size: 12px;
    margin-left: 5px;
  }
  
  @media (max-width: 768px) {
    .container {
      grid-template-columns: 1fr;
      gap: 15px;
    }
    .sidebar {
      order: -1;
    }
  }
</style>
</head>
<body>

<div class="container">
  <div class="player">
    <img id="coverArt" class="cover" src="/default-artwork.png" alt="Cover">
    <div class="song-title" id="songTitle">Loading...</div>
    <div class="song-meta" id="songMeta">--</div>
    <div class="progress-container"><div class="progress" id="progressBar"></div></div>
    <button id="startBtn">Start Stream</button>
  </div>

  <div class="sidebar">
    <div class="section">
      <h3>ðŸ‘¥ Listeners (<span id="userCount">0</span>)</h3>
      <div class="users-list" id="usersList">
        <div style="text-align: center; color: #666; padding: 20px;">No listeners yet</div>
      </div>
    </div>

    <div class="section">
      <h3>ðŸŽµ Queue (<span id="queueCount">0</span>)</h3>
      <div class="queue-list" id="queueList">
        <div style="text-align: center; color: #666; padding: 20px;">No songs queued</div>
      </div>
    </div>
  </div>
</div>

<script src="https://telegram.org/js/telegram-web-app.js"></script>
<script>
/** ---------- CONFIG + STATE ---------- **/
const streamId = location.pathname.split('/').pop();
const WS_PATH = `/stream-ws/${streamId}`;

const audioA = new Audio();
const audioB = new Audio();
let currentAudio = audioA;
let nextAudio = audioB;

let queue = [];        // [{fileName, meta}, ...]
let currentIndex = 0;  // index into queue
let serverElapsed = 0; // seconds from server
let serverUpdateAt = 0; // Date.now() when we received serverElapsed
let ws = null;
let started = false;
let users = [];
let userId = null;
let userName = null;
let heartbeatInterval = null;

// Initialize Telegram WebApp
if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
  Telegram.WebApp.ready();
  const user = Telegram.WebApp.initDataUnsafe.user;
  if (user) {
    userId = user.id;
    userName = user.first_name || user.username || `User${user.id}`;
  }
}

// Fallback for testing without Telegram
if (!userId) {
  userId = Math.random().toString(36).substr(2, 9);
  userName = 'Guest' + userId.substr(0, 4);
}

// UI elements
const songTitleEl = document.getElementById('songTitle');
const songMetaEl  = document.getElementById('songMeta');
const coverArtEl  = document.getElementById('coverArt');
const progressEl  = document.getElementById('progressBar');
const startBtn    = document.getElementById('startBtn');
const usersListEl = document.getElementById('usersList');
const userCountEl = document.getElementById('userCount');
const queueListEl = document.getElementById('queueList');
const queueCountEl = document.getElementById('queueCount');

/** ---------- HELPERS ---------- **/
function fmtDuration(seconds) {
  if (!seconds && seconds !== 0) return '--:--';
  const m = Math.floor(seconds / 60);
  const s = Math.floor(seconds % 60).toString().padStart(2, '0');
  return `${m}:${s}`;
}
function fmtViews(v) {
  if (!v) return '0 views';
  try { return Number(v).toLocaleString() + ' views'; } catch { return v + ' views'; }
}
function getDurationOf(index) {
  return queue[index]?.meta?.duration || currentAudio.duration || 1;
}

function updateMediaSession(meta = {}) {
  if (!('mediaSession' in navigator)) return;
  navigator.mediaSession.metadata = new MediaMetadata({
    title: meta.title || 'Unknown Title',
    artist: 'Live Stream',
    album: meta.published || 'Stream',
    artwork: [{ src: meta.thumbnail || '/default-artwork.png', sizes: '512x512', type: 'image/png' }]
  });
  
  // Disable all media session controls to prevent iOS interference
  navigator.mediaSession.setActionHandler('play', null);
  navigator.mediaSession.setActionHandler('pause', null);
  navigator.mediaSession.setActionHandler('previoustrack', null);
  navigator.mediaSession.setActionHandler('nexttrack', null);
  navigator.mediaSession.setActionHandler('seekto', null);
  navigator.mediaSession.setActionHandler('seekbackward', null);
  navigator.mediaSession.setActionHandler('seekforward', null);
  navigator.mediaSession.setActionHandler('stop', null);
}

function updateUI() {
  const now = queue[currentIndex];
  if (!now) return;
  songTitleEl.textContent = now.meta?.title || now.fileName;
  coverArtEl.src = now.meta?.thumbnail || '/default-artwork.png';
  songMetaEl.textContent = `${fmtDuration(now.meta?.duration)} â€¢ ${fmtViews(now.meta?.views)} â€¢ ${now.meta?.published || ''}`;
}

function updateUsersDisplay() {
  userCountEl.textContent = users.length;
  
  if (users.length === 0) {
    usersListEl.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No listeners yet</div>';
    return;
  }

  usersListEl.innerHTML = users.map(user => `
    <div class="user-item">
      <div class="user-avatar">${user.name.charAt(0).toUpperCase()}</div>
      <div class="user-name">${user.name}</div>
    </div>
  `).join('');
}

function updateQueueDisplay() {
  queueCountEl.textContent = queue.length;
  
  if (queue.length === 0) {
    queueListEl.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No songs queued</div>';
    return;
  }

  queueListEl.innerHTML = queue.map((song, index) => `
    <div class="queue-item ${index === currentIndex ? 'current' : ''}">
      <div class="queue-index">${index + 1}</div>
      <img class="queue-thumbnail" src="${song.meta?.thumbnail || '/default-artwork.png'}" alt="Thumbnail">
      <div class="queue-info">
        <div class="queue-title">
          ${song.meta?.title || song.fileName}
          ${index === currentIndex ? '<span class="current-indicator">â™ª NOW</span>' : ''}
        </div>
        <div class="queue-duration">${fmtDuration(song.meta?.duration)}</div>
      </div>
    </div>
  `).join('');
}

/** ---------- USER MANAGEMENT ---------- **/
async function joinStream() {
  try {
    const response = await fetch(`/joined/${streamId}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: userName, id: userId })
    });
    
    if (response.ok) {
      console.log('Joined stream successfully');
      fetchUsers();
    }
  } catch (error) {
    console.error('Failed to join stream:', error);
  }
}

async function leaveStream() {
  try {
    await fetch(`/left/${streamId}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ id: userId })
    });
  } catch (error) {
    console.error('Failed to leave stream:', error);
  }
}

async function fetchUsers() {
  try {
    const response = await fetch(`/list/${streamId}`);
    if (response.ok) {
      const data = await response.json();
      users = data.users || [];
      updateUsersDisplay();
    }
  } catch (error) {
    console.error('Failed to fetch users:', error);
  }
}

function startHeartbeat() {
  // Initial heartbeat
  sendHeartbeat();
  
  // Set up periodic heartbeat
  heartbeatInterval = setInterval(sendHeartbeat, 10000); // every 10s
}

async function sendHeartbeat() {
  try {
    await fetch(`/heartbeat/${streamId}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ userId: userId })
    });
  } catch (error) {
    console.error('Heartbeat failed:', error);
  }
}

/** ---------- WS HANDLING ---------- **/
function connectWS() {
  const proto = location.protocol === 'https:' ? 'wss' : 'ws';
  ws = new WebSocket(`${proto}://${location.host}${WS_PATH}`);

  ws.onopen = () => {
    console.log('WS connected');
  };

  ws.onmessage = (evt) => {
    let msg;
    try { msg = JSON.parse(evt.data); } catch { return; }
    
    if (msg.type === 'error') {
      console.error('WS error:', msg.message);
      return;
    }
    
    if (msg.type === 'user_joined' || msg.type === 'user_left') {
      // Refresh users list when someone joins/leaves
      fetchUsers();
      return;
    }
    
    if (msg.type === 'update') {
      // Update state from server
      queue = (msg.queue || []).map(item => ({
        fileName: item.fileName,
        meta: item.meta
      }));
      currentIndex = msg.currentIndex || 0;
      serverElapsed = msg.elapsed || 0;
      serverUpdateAt = Date.now();

      // If user hasn't started audio (autoplay restrictions), just refresh UI
      if (!started) {
        updateUI();
        updateQueueDisplay();
        return;
      }

      // If we are already playing, check if server says a different track is current
      // or if our elapsed differs too much; if so, re-sync immediately.
      const needTrackSwap = currentAudio.src.endsWith(`/songs/${queue[currentIndex]?.fileName}`) === false;
      const localElapsed = currentAudio.currentTime || 0;
      const predictedElapsed = serverElapsed + (Date.now() - serverUpdateAt) / 1000;
      const drift = Math.abs(localElapsed - predictedElapsed);

      if (needTrackSwap || drift > 1.0) {
        // Hard re-sync with server timeline
        primeAndPlayCurrent(predictedElapsed).catch(console.error);
      }

      // Always refresh UI and preload next
      updateUI();
      updateQueueDisplay();
      preloadNext();
    }
  };

  ws.onclose = () => {
    // Simple auto-reconnect
    setTimeout(connectWS, 1000);
  };

  ws.onerror = () => {
    try { ws.close(); } catch {}
  };
}

/** ---------- AUDIO CONTROL ---------- **/
async function primeAndPlayCurrent(forceElapsed = 0) {
  const cur = queue[currentIndex];
  if (!cur) return;

  // Set current source and position
  currentAudio.src = `/songs/${cur.fileName}`;
  // Make sure we can set currentTime: wait for metadata if needed
  if (currentAudio.readyState < 1) {
    await new Promise(res => {
      const onMeta = () => { currentAudio.removeEventListener('loadedmetadata', onMeta); res(); };
      currentAudio.addEventListener('loadedmetadata', onMeta);
      // Fallback timeout in case metadata event doesn't fire
      setTimeout(res, 300);
    });
  }
  // Clamp within track bounds
  const dur = getDurationOf(currentIndex);
  const target = Math.min(Math.max(forceElapsed || 0, 0), dur - 0.25);
  try { currentAudio.currentTime = target; } catch {}

  updateMediaSession(cur.meta);
  await currentAudio.play();

  // onended -> swap to already-preloaded next track (gapless)
  currentAudio.onended = () => {
    // Trust server to also advance its index; our UI will update via WS.
    currentIndex = (currentIndex + 1) % queue.length;
    [currentAudio, nextAudio] = [nextAudio, currentAudio];
    updateUI();
    updateQueueDisplay();
    updateMediaSession(queue[currentIndex]?.meta || {});
    currentAudio.play().catch(()=>{});
    preloadNext(); // prepare following track
  };
}

function preloadNext() {
  if (!queue.length) return;
  const nextIndex = (currentIndex + 1) % queue.length;
  const next = queue[nextIndex];
  if (!next) return;
  nextAudio.src = `/songs/${next.fileName}`;
  // Preload without autoplay
  try { nextAudio.load(); } catch {}
}

/** ---------- PROGRESS RENDER ---------- **/
function renderProgress() {
  if (!started || !queue.length) {
    requestAnimationFrame(renderProgress);
    return;
  }
  const dur = getDurationOf(currentIndex) || 1;
  const pct = Math.min((currentAudio.currentTime / dur) * 100, 100);
  progressEl.style.width = pct + '%';
  requestAnimationFrame(renderProgress);
}

/** ---------- BOOTSTRAP ---------- **/
// User gesture required: set up audio & WS
startBtn.addEventListener('click', async () => {
  if (started) return;
  started = true;

  // Join the stream
  await joinStream();
  
  // Start heartbeat
  startHeartbeat();

  connectWS();

  // Wait a moment for first WS update to arrive (initial state).
  // If none arrive quickly, fall back to one-time HTTP fetch.
  const failSafe = setTimeout(async () => {
    try {
      const res = await fetch(`/stream/${streamId}/currentTrack`);
      const data = await res.json();
      // Build queue in the same format frontend expects
      queue = (data.queue || []).map(item => ({
        fileName: item.fileName,
        meta: item.meta
      }));
      currentIndex = data.currentIndex || 0;
      serverElapsed = data.elapsed || 0;
      serverUpdateAt = Date.now();
      updateUI();
      updateQueueDisplay();
      await primeAndPlayCurrent(serverElapsed);
      preloadNext();
    } catch (e) {
      console.error('Initial HTTP sync failed:', e);
    }
  }, 500);

  // If WS update comes in before the timeout, cancel fallback
  const cancelFailSafeOnWS = (evt) => {
    try {
      const msg = JSON.parse(evt.data);
      if (msg.type === 'update') {
        clearTimeout(failSafe);
        ws.removeEventListener('message', cancelFailSafeOnWS);
        // After first WS update, actually start playback using server time
        const predictedElapsed = serverElapsed + (Date.now() - serverUpdateAt) / 1000;
        primeAndPlayCurrent(predictedElapsed).then(preloadNext).catch(console.error);
      }
    } catch {}
  };
  ws?.addEventListener('message', cancelFailSafeOnWS);

  // Start progress loop
  renderProgress();

  // Hide button
  startBtn.style.display = 'none';
});

// Handle page unload - leave stream
window.addEventListener('beforeunload', () => {
  if (heartbeatInterval) {
    clearInterval(heartbeatInterval);
  }
  if (started) {
    leaveStream();
  }
});

// Handle page visibility changes
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    // Page is hidden, but don't leave stream - heartbeat will handle timeout
  } else if (started) {
    // Page is visible again, refresh users list
    fetchUsers();
  }
});

// Initialize users display on load
fetchUsers();

</script>
</body>
</html>
