<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Live Stream Player</title>
<style>
  body {
    font-family: 'Segoe UI', sans-serif;
    background: #121212;
    color: #fff;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
  }

  .player {
    background: #1e1e1e;
    padding: 25px 30px;
    border-radius: 12px;
    width: 350px;
    text-align: center;
    box-shadow: 0 8px 20px rgba(0,0,0,0.5);
  }

  .cover {
    width: 100%;
    height: 200px;
    margin-bottom: 15px;
    border-radius: 10px;
    object-fit: cover;
    background: #333;
  }

  .song-title {
    font-size: 18px;
    font-weight: bold;
    margin-bottom: 5px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .song-meta {
    font-size: 14px;
    color: #aaa;
    margin-bottom: 15px;
  }

  .up-next {
    font-size: 14px;
    color: #bbb;
    margin-bottom: 20px;
  }

  .progress-container {
    background: #333;
    height: 8px;
    border-radius: 8px;
    width: 100%;
    margin-bottom: 20px;
  }

  .progress {
    background: #1db954;
    width: 0%;
    height: 100%;
    border-radius: 8px;
    transition: width 0.2s linear;
  }

  #startBtn {
    background: #1db954;
    border: none;
    color: #fff;
    padding: 12px 25px;
    border-radius: 25px;
    cursor: pointer;
    font-size: 16px;
  }

  #startBtn:hover {
    background: #1ed760;
  }
</style>
</head>
<body>

<div class="player">
  <img id="coverArt" class="cover" src="/default-artwork.png" alt="Cover">
  <div class="song-title" id="songTitle">Loading...</div>
  <div class="song-meta" id="songMeta">--</div>
  <div class="up-next" id="upNext">Up next: --</div>
  <div class="progress-container">
    <div class="progress" id="progressBar"></div>
  </div>
  <button id="startBtn">Start Stream</button>
</div>

<script>
const streamId = location.pathname.split('/').pop();

const audioA = new Audio();
const audioB = new Audio();
let currentAudio = audioA;
let nextAudio = audioB;
let currentIndex = 0;
let queue = [];

const songTitleEl = document.getElementById('songTitle');
const songMetaEl = document.getElementById('songMeta');
const upNextEl = document.getElementById('upNext');
const coverArtEl = document.getElementById('coverArt');
const progressBarEl = document.getElementById('progressBar');

// Media Session (iOS/Android system integration)
function updateMediaSession(meta = {}) {
  if ('mediaSession' in navigator) {
    navigator.mediaSession.metadata = new MediaMetadata({
      title: meta.title || 'Unknown Title',
      artist: "Stream",
      album: meta.published || '',
      artwork: [
        { src: meta.thumbnail || '/default-artwork.png', sizes: '512x512', type: 'image/png' }
      ]
    });

    navigator.mediaSession.setActionHandler('play', () => currentAudio.play());
    navigator.mediaSession.setActionHandler('pause', () => currentAudio.pause());
    navigator.mediaSession.setActionHandler('nexttrack', () => currentAudio.onended());
  }
}

function updateUI() {
  const currentSong = queue[currentIndex];
  if (!currentSong) return;

  songTitleEl.textContent = currentSong.meta?.title || currentSong.fileName;
  coverArtEl.src = currentSong.meta?.thumbnail || '/default-artwork.png';
  
  songMetaEl.textContent = `${formatDuration(currentSong.meta?.duration)} • ${formatViews(currentSong.meta?.views)} • ${currentSong.meta?.published || ''}`;

  const nextSong = queue[(currentIndex + 1) % queue.length];
  if (nextSong) {
    upNextEl.textContent = "Up next: " + (nextSong.meta?.title || nextSong.fileName);
  } else {
    upNextEl.textContent = "Up next: --";
  }
}

// format helpers
function formatDuration(seconds) {
  if (!seconds) return "--:--";
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60).toString().padStart(2, '0');
  return `${mins}:${secs}`;
}
function formatViews(views) {
  if (!views) return "0 views";
  return views.toLocaleString() + " views";
}

async function syncStream(initial = false) {
  try {
    const res = await fetch(`/stream/${streamId}/currentTrack`);
    const data = await res.json();
    queue = data.queue;
    currentIndex = data.currentIndex;

    updateUI();
    updateMediaSession(queue[currentIndex].meta);

    if (initial) {
      currentAudio.src = `/songs/${queue[currentIndex].fileName}`;
      currentAudio.currentTime = data.elapsed;
      await currentAudio.play();

      // preload next
      const nextIndex = (currentIndex + 1) % queue.length;
      nextAudio.src = `/songs/${queue[nextIndex].fileName}`;
      nextAudio.load();

      currentAudio.onended = () => {
        currentIndex = (currentIndex + 1) % queue.length;
        [currentAudio, nextAudio] = [nextAudio, currentAudio];

        updateUI();
        updateMediaSession(queue[currentIndex].meta);

        currentAudio.play();

        const followingIndex = (currentIndex + 1) % queue.length;
        nextAudio.src = `/songs/${queue[followingIndex].fileName}`;
        nextAudio.load();
      };
    }
  } catch (err) {
    console.error("Sync error:", err);
  }
}

// progress updater
async function updateProgress() {
  try {
    const res = await fetch(`/stream/${streamId}/currentTrack`);
    const data = await res.json();
    const elapsed = data.elapsed;
    const duration = queue[data.currentIndex]?.meta?.duration || 1;
    const percent = Math.min((elapsed / duration) * 100, 100);
    progressBarEl.style.width = percent + '%';
  } catch (err) {
    console.error("Progress error:", err);
  }
  requestAnimationFrame(updateProgress);
}

// start stream
document.getElementById('startBtn').addEventListener('click', async () => {
  await syncStream(true);
  updateProgress();
  document.getElementById('startBtn').style.display = 'none';
});
</script>

</body>
</html>
