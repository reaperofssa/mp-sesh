<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<!-- Updated title to ReikerNx -->
<title>ReikerNx - Live Stream Player</title>
<style>
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #000000;
    color: #ffffff;
    margin: 0;
    padding: 20px;
    min-height: 100vh;
  }
  
  /* Added iOS liquid glass container with backdrop blur */
  .container {
    max-width: 800px;
    margin: 0 auto;
    display: grid;
    grid-template-columns: 1fr 300px;
    gap: 20px;
    position: relative;
  }
  
  /* Enhanced player with iOS liquid glass styling */
  .player {
    background: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border: 1px solid rgba(29, 185, 84, 0.3);
    padding: 30px;
    border-radius: 24px;
    text-align: center;
    box-shadow: 
      0 8px 32px rgba(29, 185, 84, 0.15),
      inset 0 1px 0 rgba(255, 255, 255, 0.1),
      inset 0 -1px 0 rgba(0, 0, 0, 0.2);
    height: fit-content;
    position: relative;
    overflow: hidden;
  }
  
  /* Added subtle glass reflection overlay */
  .player::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 50%;
    background: linear-gradient(180deg, rgba(255, 255, 255, 0.05) 0%, transparent 100%);
    pointer-events: none;
    border-radius: 24px 24px 0 0;
  }
  
  /* Updated site branding to ReikerNx */
  .site-branding {
    position: absolute;
    top: 15px;
    left: 20px;
    font-size: 14px;
    font-weight: bold;
    color: #1db954;
    letter-spacing: 1px;
    text-transform: uppercase;
  }
  
  .spotify-logo {
    position: absolute;
    top: 15px;
    right: 20px;
    width: 24px;
    height: 24px;
    fill: #1db954;
  }
  
  /* Enhanced sidebar with liquid glass effect */
  .sidebar {
    background: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border: 1px solid rgba(29, 185, 84, 0.3);
    padding: 20px;
    border-radius: 24px;
    box-shadow: 
      0 8px 32px rgba(29, 185, 84, 0.15),
      inset 0 1px 0 rgba(255, 255, 255, 0.1),
      inset 0 -1px 0 rgba(0, 0, 0, 0.2);
    height: fit-content;
    position: relative;
    overflow: hidden;
  }
  
  /* Added glass reflection to sidebar */
  .sidebar::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 50%;
    background: linear-gradient(180deg, rgba(255, 255, 255, 0.05) 0%, transparent 100%);
    pointer-events: none;
    border-radius: 24px 24px 0 0;
  }
  
  /* Enhanced cover art with liquid glass border */
  .cover {
    width: 100%; 
    height: 220px; 
    margin-bottom: 20px;
    border-radius: 20px; 
    object-fit: cover; 
    background: #111111;
    border: 2px solid rgba(29, 185, 84, 0.4);
    box-shadow: 
      0 8px 24px rgba(29, 185, 84, 0.2),
      inset 0 1px 0 rgba(255, 255, 255, 0.1);
    position: relative;
    overflow: hidden;
  }
  
  .song-title {
    font-size: 20px; 
    font-weight: bold; 
    margin-bottom: 8px;
    overflow: hidden; 
    text-overflow: ellipsis; 
    white-space: nowrap;
    color: #ffffff;
    text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    position: relative;
    z-index: 1;
  }
  
  .song-meta { 
    font-size: 14px; 
    color: #b3b3b3; 
    margin-bottom: 20px;
    position: relative;
    z-index: 1;
  }
  
  /* Enhanced progress container with glass styling */
  .progress-container {
    background: rgba(51, 51, 51, 0.6); 
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    height: 8px; 
    border-radius: 12px;
    width: 100%; 
    margin-bottom: 25px; 
    overflow: hidden;
    box-shadow: 
      inset 0 2px 4px rgba(0,0,0,0.3),
      inset 0 1px 0 rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.1);
    position: relative;
    z-index: 1;
  }
  
  .progress {
    background: linear-gradient(90deg, #1db954, #1ed760); 
    width: 0%; 
    height: 100%;
    transition: width 0.15s linear;
    border-radius: 12px;
    box-shadow: 0 0 12px rgba(29, 185, 84, 0.4);
  }
  
  /* Enhanced button with liquid glass effect */
  #startBtn {
    background: rgba(29, 185, 84, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2); 
    color: #000000;
    padding: 16px 32px; 
    border-radius: 20px; 
    cursor: pointer; 
    font-size: 16px;
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 1px;
    box-shadow: 
      0 8px 24px rgba(29, 185, 84, 0.3),
      inset 0 1px 0 rgba(255, 255, 255, 0.2),
      inset 0 -1px 0 rgba(0, 0, 0, 0.1);
    transition: all 0.3s ease;
    position: relative;
    z-index: 1;
    overflow: hidden;
  }
  
  /* Added glass reflection to button */
  #startBtn::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 50%;
    background: linear-gradient(180deg, rgba(255, 255, 255, 0.2) 0%, transparent 100%);
    pointer-events: none;
    border-radius: 20px 20px 0 0;
  }
  
  #startBtn:hover { 
    background: rgba(30, 215, 96, 0.95);
    transform: translateY(-2px);
    box-shadow: 
      0 12px 32px rgba(29, 185, 84, 0.4),
      inset 0 1px 0 rgba(255, 255, 255, 0.3),
      inset 0 -1px 0 rgba(0, 0, 0, 0.1);
  }
  
  .section {
    margin-bottom: 30px;
    position: relative;
    z-index: 1;
  }
  
  /* Enhanced section headers with glass styling */
  .section h3 {
    font-size: 16px;
    margin-bottom: 15px;
    color: #ffffff;
    border-bottom: 2px solid rgba(29, 185, 84, 0.6);
    padding-bottom: 8px;
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
  }
  
  /* Enhanced scrollbars with glass effect */
  .users-list {
    max-height: 200px;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: rgba(29, 185, 84, 0.8) transparent;
  }
  .users-list::-webkit-scrollbar {
    width: 8px;
  }
  .users-list::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.3);
    border-radius: 10px;
  }
  .users-list::-webkit-scrollbar-thumb {
    background: rgba(29, 185, 84, 0.8);
    border-radius: 10px;
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
  }
  
  /* Enhanced user items with liquid glass hover */
  .user-item {
    display: flex;
    align-items: center;
    padding: 12px 0;
    border-bottom: 1px solid rgba(29, 185, 84, 0.2);
    transition: all 0.3s ease;
    border-radius: 12px;
  }
  .user-item:last-child {
    border-bottom: none;
  }
  .user-item:hover {
    background: rgba(29, 185, 84, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(29, 185, 84, 0.3);
    padding: 12px 8px;
    box-shadow: 
      0 4px 16px rgba(29, 185, 84, 0.1),
      inset 0 1px 0 rgba(255, 255, 255, 0.1);
  }
  
  /* Enhanced user avatar with glass effect */
  .user-avatar {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    background: rgba(29, 185, 84, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 12px;
    font-weight: bold;
    font-size: 14px;
    color: #000000;
    box-shadow: 
      0 4px 12px rgba(29, 185, 84, 0.3),
      inset 0 1px 0 rgba(255, 255, 255, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.2);
  }
  
  .user-name {
    font-size: 14px;
    color: #ffffff;
    font-weight: 500;
  }
  
  .queue-list {
    max-height: 300px;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: rgba(29, 185, 84, 0.8) transparent;
  }
  .queue-list::-webkit-scrollbar {
    width: 8px;
  }
  .queue-list::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.3);
    border-radius: 10px;
  }
  .queue-list::-webkit-scrollbar-thumb {
    background: rgba(29, 185, 84, 0.8);
    border-radius: 10px;
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
  }
  
  /* Enhanced queue items with glass styling */
  .queue-item {
    display: flex;
    padding: 12px 0;
    border-bottom: 1px solid rgba(29, 185, 84, 0.2);
    transition: all 0.3s ease;
    border-radius: 12px;
  }
  .queue-item:last-child {
    border-bottom: none;
  }
  .queue-item:hover {
    background: rgba(29, 185, 84, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(29, 185, 84, 0.3);
    padding: 12px 8px;
    box-shadow: 
      0 4px 16px rgba(29, 185, 84, 0.1),
      inset 0 1px 0 rgba(255, 255, 255, 0.1);
  }
  
  /* Enhanced current queue item with stronger glass effect */
  .queue-item.current {
    background: rgba(29, 185, 84, 0.2);
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    border: 1px solid rgba(29, 185, 84, 0.5);
    border-radius: 16px;
    padding: 12px;
    margin: 5px 0;
    box-shadow: 
      0 8px 24px rgba(29, 185, 84, 0.2),
      inset 0 1px 0 rgba(255, 255, 255, 0.2),
      inset 0 -1px 0 rgba(0, 0, 0, 0.1);
  }
  
  /* Enhanced queue thumbnail with glass border */
  .queue-thumbnail {
    width: 44px;
    height: 44px;
    border-radius: 12px;
    object-fit: cover;
    margin-right: 12px;
    background: #111111;
    border: 1px solid rgba(29, 185, 84, 0.4);
    box-shadow: 
      0 2px 8px rgba(29, 185, 84, 0.1),
      inset 0 1px 0 rgba(255, 255, 255, 0.1);
  }
  
  .queue-info {
    flex: 1;
  }
  .queue-title {
    font-size: 14px;
    font-weight: 600;
    color: #ffffff;
    margin-bottom: 4px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .queue-duration {
    font-size: 12px;
    color: #b3b3b3;
  }
  .queue-index {
    font-size: 12px;
    color: #1db954;
    margin-right: 12px;
    font-weight: bold;
    min-width: 24px;
    text-align: center;
  }
  .current-indicator {
    color: #1db954;
    font-size: 12px;
    margin-left: 8px;
    font-weight: bold;
    text-shadow: 0 0 8px rgba(29, 185, 84, 0.6);
  }
  
  .empty-state {
    text-align: center; 
    color: #666666; 
    padding: 20px;
    font-style: italic;
  }
  
  @media (max-width: 768px) {
    .container {
      grid-template-columns: 1fr;
      gap: 15px;
    }
    .sidebar {
      order: -1;
    }
    .player {
      padding: 20px;
    }
  }
</style>
</head>
<body>

<div class="container">
  <div class="player">
    <!-- Added ReikerNx branding -->
    <div class="site-branding">ReikerNx</div>
    
    <svg class="spotify-logo" viewBox="0 0 24 24">
      <path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.42 1.56-.299.421-1.02.599-1.559.3z"/>
    </svg>
    
    <img id="coverArt" class="cover" src="/default-artwork.png" alt="Cover">
    <div class="song-title" id="songTitle">Loading...</div>
    <div class="song-meta" id="songMeta">--</div>
    <div class="progress-container"><div class="progress" id="progressBar"></div></div>
    <button id="startBtn">â–¶ Start Stream</button>
  </div>

  <div class="sidebar">
    <div class="section">
      <h3>ðŸŽ§ Listeners (<span id="userCount">0</span>)</h3>
      <div class="users-list" id="usersList">
        <div class="empty-state">No listeners yet</div>
      </div>
    </div>

    <div class="section">
      <h3>ðŸŽµ Queue (<span id="queueCount">0</span>)</h3>
      <div class="queue-list" id="queueList">
        <div class="empty-state">No songs queued</div>
      </div>
    </div>
  </div>
</div>

<script src="https://telegram.org/js/telegram-web-app.js"></script>
<script>
/** ---------- CONFIG + STATE ---------- **/
const streamId = location.pathname.split('/').pop();
const WS_PATH = `/stream-ws/${streamId}`;

const audioA = new Audio();
const audioB = new Audio();
let currentAudio = audioA;
let nextAudio = audioB;

let queue = [];        // [{fileName, meta}, ...]
let currentIndex = 0;  // index into queue
let serverElapsed = 0; // seconds from server
let serverUpdateAt = 0; // Date.now() when we received serverElapsed
let ws = null;
let started = false;
let users = [];
let userId = null;
let userName = null;
let heartbeatInterval = null;

// Initialize Telegram WebApp
if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
  Telegram.WebApp.ready();
  const user = Telegram.WebApp.initDataUnsafe.user;
  if (user) {
    userId = user.id;
    userName = user.first_name || user.username || `User${user.id}`;
  }
}

// Fallback for testing without Telegram
if (!userId) {
  userId = Math.random().toString(36).substr(2, 9);
  userName = 'Guest' + userId.substr(0, 4);
}

// UI elements
const songTitleEl = document.getElementById('songTitle');
const songMetaEl  = document.getElementById('songMeta');
const coverArtEl  = document.getElementById('coverArt');
const progressEl  = document.getElementById('progressBar');
const startBtn    = document.getElementById('startBtn');
const usersListEl = document.getElementById('usersList');
const userCountEl = document.getElementById('userCount');
const queueListEl = document.getElementById('queueList');
const queueCountEl = document.getElementById('queueCount');

/** ---------- HELPERS ---------- **/
function fmtDuration(seconds) {
  if (!seconds && seconds !== 0) return '--:--';
  const m = Math.floor(seconds / 60);
  const s = Math.floor(seconds % 60).toString().padStart(2, '0');
  return `${m}:${s}`;
}
function fmtViews(v) {
  if (!v) return '0 views';
  try { return Number(v).toLocaleString() + ' views'; } catch { return v + ' views'; }
}
function getDurationOf(index) {
  return queue[index]?.meta?.duration || currentAudio.duration || 1;
}

function updateMediaSession(meta = {}) {
  if (!('mediaSession' in navigator)) return;
  navigator.mediaSession.metadata = new MediaMetadata({
    title: meta.title || 'Unknown Title',
    artist: 'Live Stream',
    album: meta.published || 'Stream',
    artwork: [{ src: meta.thumbnail || '/default-artwork.png', sizes: '512x512', type: 'image/png' }]
  });
  
  // Disable all media session controls to prevent iOS interference
  navigator.mediaSession.setActionHandler('play', null);
  navigator.mediaSession.setActionHandler('pause', null);
  navigator.mediaSession.setActionHandler('previoustrack', null);
  navigator.mediaSession.setActionHandler('nexttrack', null);
  navigator.mediaSession.setActionHandler('seekto', null);
  navigator.mediaSession.setActionHandler('seekbackward', null);
  navigator.mediaSession.setActionHandler('seekforward', null);
  navigator.mediaSession.setActionHandler('stop', null);
}

function updateUI() {
  const now = queue[currentIndex];
  if (!now) return;
  songTitleEl.textContent = now.meta?.title || now.fileName;
  coverArtEl.src = now.meta?.thumbnail || '/default-artwork.png';
  songMetaEl.textContent = `${fmtDuration(now.meta?.duration)} â€¢ ${fmtViews(now.meta?.views)} â€¢ ${now.meta?.published || ''}`;
}

function updateUsersDisplay() {
  userCountEl.textContent = users.length;
  
  if (users.length === 0) {
    usersListEl.innerHTML = '<div class="empty-state">No listeners yet</div>';
    return;
  }

  usersListEl.innerHTML = users.map(user => `
    <div class="user-item">
      <div class="user-avatar">${user.name.charAt(0).toUpperCase()}</div>
      <div class="user-name">${user.name}</div>
    </div>
  `).join('');
}

function updateQueueDisplay() {
  queueCountEl.textContent = queue.length;
  
  if (queue.length === 0) {
    queueListEl.innerHTML = '<div class="empty-state">No songs queued</div>';
    return;
  }

  queueListEl.innerHTML = queue.map((song, index) => `
    <div class="queue-item ${index === currentIndex ? 'current' : ''}">
      <div class="queue-index">${index + 1}</div>
      <img class="queue-thumbnail" src="${song.meta?.thumbnail || '/default-artwork.png'}" alt="Thumbnail">
      <div class="queue-info">
        <div class="queue-title">
          ${song.meta?.title || song.fileName}
          ${index === currentIndex ? '<span class="current-indicator">â™ª NOW</span>' : ''}
        </div>
        <div class="queue-duration">${fmtDuration(song.meta?.duration)}</div>
      </div>
    </div>
  `).join('');
}

/** ---------- USER MANAGEMENT ---------- **/
async function joinStream() {
  try {
    const response = await fetch(`/joined/${streamId}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: userName, id: userId })
    });
    
    if (response.ok) {
      console.log('Joined stream successfully');
      fetchUsers();
    }
  } catch (error) {
    console.error('Failed to join stream:', error);
  }
}

async function leaveStream() {
  try {
    await fetch(`/left/${streamId}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ id: userId })
    });
  } catch (error) {
    console.error('Failed to leave stream:', error);
  }
}

async function fetchUsers() {
  try {
    const response = await fetch(`/list/${streamId}`);
    if (response.ok) {
      const data = await response.json();
      users = data.users || [];
      updateUsersDisplay();
    }
  } catch (error) {
    console.error('Failed to fetch users:', error);
  }
}

function startHeartbeat() {
  // Initial heartbeat
  sendHeartbeat();
  
  // Set up periodic heartbeat
  heartbeatInterval = setInterval(sendHeartbeat, 10000); // every 10s
}

async function sendHeartbeat() {
  try {
    await fetch(`/heartbeat/${streamId}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ userId: userId })
    });
  } catch (error) {
    console.error('Heartbeat failed:', error);
  }
}

/** ---------- WS HANDLING ---------- **/
function connectWS() {
  const proto = location.protocol === 'https:' ? 'wss' : 'ws';
  ws = new WebSocket(`${proto}://${location.host}${WS_PATH}`);

  ws.onopen = () => {
    console.log('WS connected');
  };

  ws.onmessage = (evt) => {
    let msg;
    try { msg = JSON.parse(evt.data); } catch { return; }
    
    if (msg.type === 'error') {
      console.error('WS error:', msg.message);
      return;
    }
    
    if (msg.type === 'user_joined' || msg.type === 'user_left') {
      // Refresh users list when someone joins/leaves
      fetchUsers();
      return;
    }
    
    if (msg.type === 'update') {
      // Update state from server
      queue = (msg.queue || []).map(item => ({
        fileName: item.fileName,
        meta: item.meta
      }));
      currentIndex = msg.currentIndex || 0;
      serverElapsed = msg.elapsed || 0;
      serverUpdateAt = Date.now();

      // If user hasn't started audio (autoplay restrictions), just refresh UI
      if (!started) {
        updateUI();
        updateQueueDisplay();
        return;
      }

      // If we are already playing, check if server says a different track is current
      // or if our elapsed differs too much; if so, re-sync immediately.
      const needTrackSwap = currentAudio.src.endsWith(`/songs/${queue[currentIndex]?.fileName}`) === false;
      const localElapsed = currentAudio.currentTime || 0;
      const predictedElapsed = serverElapsed + (Date.now() - serverUpdateAt) / 1000;
      const drift = Math.abs(localElapsed - predictedElapsed);

      if (needTrackSwap || drift > 1.0) {
        // Hard re-sync with server timeline
        primeAndPlayCurrent(predictedElapsed).catch(console.error);
      }

      // Always refresh UI and preload next
      updateUI();
      updateQueueDisplay();
      preloadNext();
    }
  };

  ws.onclose = () => {
    // Simple auto-reconnect
    setTimeout(connectWS, 1000);
  };

  ws.onerror = () => {
    try { ws.close(); } catch {}
  };
}

/** ---------- AUDIO CONTROL ---------- **/
async function primeAndPlayCurrent(forceElapsed = 0) {
  const cur = queue[currentIndex];
  if (!cur) return;

  // Set current source and position
  currentAudio.src = `/songs/${cur.fileName}`;
  // Make sure we can set currentTime: wait for metadata if needed
  if (currentAudio.readyState < 1) {
    await new Promise(res => {
      const onMeta = () => { currentAudio.removeEventListener('loadedmetadata', onMeta); res(); };
      currentAudio.addEventListener('loadedmetadata', onMeta);
      // Fallback timeout in case metadata event doesn't fire
      setTimeout(res, 300);
    });
  }
  // Clamp within track bounds
  const dur = getDurationOf(currentIndex);
  const target = Math.min(Math.max(forceElapsed || 0, 0), dur - 0.25);
  try { currentAudio.currentTime = target; } catch {}

  updateMediaSession(cur.meta);
  await currentAudio.play();

  // onended -> swap to already-preloaded next track (gapless)
  currentAudio.onended = () => {
    // Trust server to also advance its index; our UI will update via WS.
    currentIndex = (currentIndex + 1) % queue.length;
    [currentAudio, nextAudio] = [nextAudio, currentAudio];
    updateUI();
    updateQueueDisplay();
    updateMediaSession(queue[currentIndex]?.meta || {});
    currentAudio.play().catch(()=>{});
    preloadNext(); // prepare following track
  };
}

function preloadNext() {
  if (!queue.length) return;
  const nextIndex = (currentIndex + 1) % queue.length;
  const next = queue[nextIndex];
  if (!next) return;
  nextAudio.src = `/songs/${next.fileName}`;
  // Preload without autoplay
  try { nextAudio.load(); } catch {}
}

/** ---------- PROGRESS RENDER ---------- **/
function renderProgress() {
  if (!started || !queue.length) {
    requestAnimationFrame(renderProgress);
    return;
  }
  const dur = getDurationOf(currentIndex) || 1;
  const pct = Math.min((currentAudio.currentTime / dur) * 100, 100);
  progressEl.style.width = pct + '%';
  requestAnimationFrame(renderProgress);
}

/** ---------- BOOTSTRAP ---------- **/
// User gesture required: set up audio & WS
startBtn.addEventListener('click', async () => {
  if (started) return;
  started = true;

  // Join the stream
  await joinStream();
  
  // Start heartbeat
  startHeartbeat();

  connectWS();

  // Wait a moment for first WS update to arrive (initial state).
  // If none arrive quickly, fall back to one-time HTTP fetch.
  const failSafe = setTimeout(async () => {
    try {
      const res = await fetch(`/stream/${streamId}/currentTrack`);
      const data = await res.json();
      // Build queue in the same format frontend expects
      queue = (data.queue || []).map(item => ({
        fileName: item.fileName,
        meta: item.meta
      }));
      currentIndex = data.currentIndex || 0;
      serverElapsed = data.elapsed || 0;
      serverUpdateAt = Date.now();
      updateUI();
      updateQueueDisplay();
      await primeAndPlayCurrent(serverElapsed);
      preloadNext();
    } catch (e) {
      console.error('Initial HTTP sync failed:', e);
    }
  }, 500);

  // If WS update comes in before the timeout, cancel fallback
  const cancelFailSafeOnWS = (evt) => {
    try {
      const msg = JSON.parse(evt.data);
      if (msg.type === 'update') {
        clearTimeout(failSafe);
        ws.removeEventListener('message', cancelFailSafeOnWS);
        // After first WS update, actually start playback using server time
        const predictedElapsed = serverElapsed + (Date.now() - serverUpdateAt) / 1000;
        primeAndPlayCurrent(predictedElapsed).then(preloadNext).catch(console.error);
      }
    } catch {}
  };
  ws?.addEventListener('message', cancelFailSafeOnWS);

  // Start progress loop
  renderProgress();

  // Hide button
  startBtn.style.display = 'none';
});

// Handle page unload - leave stream
window.addEventListener('beforeunload', () => {
  if (heartbeatInterval) {
    clearInterval(heartbeatInterval);
  }
  if (started) {
    leaveStream();
  }
});

// Handle page visibility changes
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    // Page is hidden, but don't leave stream - heartbeat will handle timeout
  } else if (started) {
    // Page is visible again, refresh users list
    fetchUsers();
  }
});

// Initialize users display on load
fetchUsers();

</script>
</body>
</html>
